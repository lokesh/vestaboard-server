<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no">
    <title>108 Space</title>
    <link rel="icon" type="image/png" href="/images/favicon.png">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap">
    <link rel="stylesheet" href="styles.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
</head>
<body>
    <div id="app">
        <div class="container" :class="{ 'blur-background': isMessageModalOpen || isImageModalOpen }">
            <div class="board board-mock">
                <div class="board-grid">
                    <div v-for="(char, index) in boardContent" 
                         :key="index" 
                         :class="['grid-cell', { 'animating': animatingCells.has(index) }]">
                        <template v-if="isColorEmoji(char)">
                            <div :class="['color-block', `color-${getColorClass(char)}`, { 'animating': animatingCells.has(index) }]"></div>
                        </template>
                        <template v-else>
                            {{ char || '\u00A0' }}
                        </template>
                    </div>
                </div>
            </div>

            <div class="update-timing">{{ cronSchedule }}</div>

            <div class="mode-grid">
                <div v-for="mode in modes" 
                     :key="mode.name"
                     :class="['mode', `mode-${mode.name.toLowerCase()}`, { 'mode-active': currentMode === mode.name }]"
                     @click="setMode(mode.name)">
                    <img :src="`images/icon-mode-${mode.name.toLowerCase()}.svg`" alt="Mode" class="mode-icon">
                    <div class="mode-label">
                        <div class="mode-title">{{ mode.title }}</div>
                        <div class="mode-subtitle">{{ mode.subtitle }}</div>
                    </div>
                </div>
            </div>

            <div class="action-grid">
                <div class="action action-message" @click="openMessageModal">
                    <img src="images/icon-action-message.svg" alt="Message" class="action-icon">
                    <div class="action-title">Message</div>
                </div>

                <div class="action action-image" @click="openImageModal">
                    <img src="images/icon-action-image.svg" alt="Image" class="action-icon">
                    <div class="action-title">Image</div>
                </div>
            </div>

            <div class="action-grid">
                <div class="action action-debug" @click="toggleDebug()">
                    <div class="action-title">Debug</div>
                    <div class="toggle-switch" :class="{ 'active': debugStatus.includes('DEBUG') }">
                        <div class="toggle-circle"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="debug-only-content" :class="{ 'hidden': !debugStatus.includes('DEBUG') }">
            <div class="status-panel">
                <div id="debug-status" style="margin-bottom: 8px;">{{ debugStatus }}</div>
            </div>

            <div>Mode: <span>{{ currentMode || 'Loading...' }}</span></div>            

            <div class="pattern-test-panel">
                <h2>Pattern Tests</h2>
                <div class="control-panel">
                    <button v-for="mode in testModes" 
                            :key="mode"
                            class="button"
                            @click="testPattern(mode)">
                        Test {{ mode }}
                    </button>
                </div>
                <div id="pattern-test-results">
                    <div class="status-item">
                        <span class="status-label">Last Test:&nbsp;</span>
                        <span>{{ patternTest.mode }}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Result:&nbsp;</span>
                        <span :style="{ color: patternTest.color }">{{ patternTest.result }}</span>
                    </div>
                    <div class="status-item">
                        <span class="status-label">Time:&nbsp;</span>
                        <span>{{ patternTest.time }}</span>
                    </div>
                </div>
            </div>

            <div class="status-item">
                <span class="status-label">Cron:&nbsp;</span>
                <span>{{ cronSchedule }}</span>
            </div>

            <div class="calendar-debug">
                <h2>Calendar</h2>
                <div class="status-item">
                    <span class="status-label">Calendar Auth Status:</span>
                    <span>{{ calendarAuthStatus }}</span>
                </div>
                <div class="control-panel">
                    <button class="button" @click="initiateCalendarAuth">Start Calendar Auth</button>
                    <button class="button" @click="fetchCalendarEvents">Fetch Calendar Events</button>
                </div>
                <div>
                    Latest Events:<br />
                    <div id="calendar-events-container" style="max-width: 100%; overflow-x: hidden;">
                        <pre>{{ calendarEvents }}</pre>
                        <div>{{ calendarEventsTimestamp }}</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Message Modal -->
        <div class="message-modal" :class="{ 'show': isMessageModalOpen }" @click.self="closeMessageModal">
            <div class="modal-content">
                <div class="message-input-container">
                    <textarea 
                        ref="messageTextarea"
                        v-model="messageInput"
                        placeholder="Enter your message here..."
                        rows="6"
                        maxlength="132"></textarea>
                    <div style="display: flex; justify-content: flex-end;">
                        <button class="button" @click="sendMessage">Send</button>
                    </div>
                    <div v-if="false" :style="{ color: messageStatus.color }">{{ messageStatus.text }}</div>
                </div>
            </div>
        </div>

        <!-- Image Grid -->
        <div class="image-grid-overlay" :class="{ 'show': isImageModalOpen }" @click.self="closeImageModal">
            <div class="image-grid">
                <!-- Checkerboard -->
                <div class="image-box" @click="applyTestPattern(findPatternById('checkerboard'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <div v-for="col in 22" class="preview-cell">
                                    <div :class="['color-block', ((row + col) % 2 === 0) ? 'color-white' : 'color-black']"></div>
                                </div>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Checkerboard</div>
                </div>

                <!-- Color Blocks -->
                <div class="image-box" @click="applyTestPattern(findPatternById('color-blocks'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-red"></div></div>
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-orange"></div></div>
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-yellow"></div></div>
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-green"></div></div>
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-blue"></div></div>
                            <div class="preview-cell" v-for="i in 22"><div class="color-block color-purple"></div></div>
                        </div>
                    </div>
                    <div class="image-title">Color Blocks</div>
                </div>

                <!-- Color Waves -->
                <div class="image-box" @click="applyTestPattern(findPatternById('color-waves'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['blue', 'green', 'yellow'][Math.floor((Math.sin(col * 0.3 + row * 0.5) + 1) * 1.5)]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Color Waves</div>
                </div>

                <!-- Herringbone -->
                <div class="image-box" @click="applyTestPattern(findPatternById('herringbone'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((row * 2 + col) % 4 < 2) ? 'color-blue' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Herringbone</div>
                </div>

                <!-- Basket Weave -->
                <div class="image-box" @click="applyTestPattern(findPatternById('tartan'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((row + col) % 3 === 0) ? 'color-black' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Tartan</div>
                </div>

                <!-- Diagonal Weave -->
                <div class="image-box" @click="applyTestPattern(findPatternById('diagonal-weave'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((row + col) % 3 === 0) ? 'color-black' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Diagonal Weave</div>
                </div>

                <!-- Interlocking T -->
                <div class="image-box" @click="applyTestPattern(findPatternById('interlocking-t'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', (row % 3 === 1 || col % 3 === 1) ? 'color-black' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Interlocking T</div>
                </div>

                <!-- Broken Stripes -->
                <div class="image-box" @click="applyTestPattern(findPatternById('broken-stripes'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((col + Math.floor(row/2)) % 4 < 2) ? 'color-black' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Broken Stripes</div>
                </div>

                <!-- Maze Pattern -->
                <div class="image-box" @click="applyTestPattern(findPatternById('maze-pattern'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((row % 4 < 2) !== (col % 4 < 2)) ? 'color-black' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Maze Pattern</div>
                </div>

                <!-- Color Gradient Weave -->
                <div class="image-box" @click="applyTestPattern(findPatternById('color-gradient-weave'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((row + col) % 2 === 0) ? `color-${['red', 'orange', 'yellow', 'green', 'blue', 'purple'][(row + Math.floor(col/4)) % 6]}` : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Color Gradient Weave</div>
                </div>

                <!-- Rainbow Diamonds -->
                <div class="image-box" @click="applyTestPattern(findPatternById('rainbow-diamonds'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['red', 'orange', 'yellow', 'green', 'blue', 'purple'][Math.floor(Math.abs(row - 2.5) + Math.abs(col - 10.5)) % 6]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Rainbow Diamonds</div>
                </div>

                <!-- Color Steps -->
                <div class="image-box" @click="applyTestPattern(findPatternById('color-steps'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['red', 'orange', 'yellow', 'green', 'blue', 'purple'][Math.floor((row + col) / 3) % 6]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Color Steps</div>
                </div>

                <!-- Rainbow Maze -->
                <div class="image-box" @click="applyTestPattern(findPatternById('rainbow-maze'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', (row % 3 === 1 || col % 3 === 1) ? `color-${['red', 'orange', 'yellow', 'green', 'blue', 'purple'][((row % 3) * 2 + (col % 3)) % 6]}` : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Rainbow Maze</div>
                </div>

                <!-- Spectrum Blocks -->
                <div class="image-box" @click="applyTestPattern(findPatternById('spectrum-blocks'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['red', 'orange', 'yellow', 'green', 'blue', 'purple'][(Math.floor(row/3) + Math.floor(col/3)) % 6]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Spectrum Blocks</div>
                </div>

                <!-- Ikat Waves -->
                <div class="image-box" @click="applyTestPattern(findPatternById('ikat-waves'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['red', 'blue', 'white'][Math.floor((Math.sin(col * 0.4 + row * 0.8) + 1) * 1.5)]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Ikat Waves</div>
                </div>

                <!-- Tartan -->
                <div class="image-box" @click="applyTestPattern(findPatternById('tartan'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['blue', 'green', 'white', 'red'][(col % 4 === 0 || row % 4 === 0) ? Math.floor(row/2) % 4 : Math.floor(col/2) % 4]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Tartan</div>
                </div>

                <!-- Kente Inspired -->
                <div class="image-box" @click="applyTestPattern(findPatternById('kente'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', `color-${['yellow', 'green', 'red', 'black'][((col % 4) + (row % 2) * 2) % 4]}`]"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Kente Inspired</div>
                </div>

                <!-- Twill Pattern -->
                <div class="image-box" @click="applyTestPattern(findPatternById('twill'))">
                    <div class="image-preview">
                        <div class="preview-grid">
                            <template v-for="row in 6">
                                <template v-for="col in 22">
                                    <div class="preview-cell">
                                        <div :class="['color-block', ((col + row % 4) % 4 < 2) ? 'color-blue' : 'color-white']"></div>
                                    </div>
                                </template>
                            </template>
                        </div>
                    </div>
                    <div class="image-title">Twill Pattern</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, onMounted, watch, nextTick } = Vue;

        const charMap = {
            ' ': 0,
            'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9,
            'J': 10, 'K': 11, 'L': 12, 'M': 13, 'N': 14, 'O': 15, 'P': 16, 'Q': 17,
            'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22, 'W': 23, 'X': 24, 'Y': 25,
            'Z': 26,
            '1': 27, '2': 28, '3': 29, '4': 30, '5': 31, '6': 32, '7': 33, '8': 34,
            '9': 35, '0': 36,
            '!': 37, '@': 38, '#': 39, '$': 40, '(': 41, ')': 42, '-': 44, '+': 46,
            '&': 47, '=': 48, ';': 49, ':': 50, "'": 52, '"': 53, '%': 54, ',': 55,
            '.': 56, '/': 59, '?': 60, '°': 62,
            '🟥': 63, '🟧': 64, '🟨': 65, '🟩': 66, '🟦': 67, '🟪': 68, '⬜': 69, 
            '⬛': 70, '⬛️': 70, '\u2B1B': 70, '\u2B1B\uFE0F': 70,  // All black square variations
            '■': 71
        };

        // Create code to char map for API responses
        const codeToChar = {};
        Object.entries(charMap).forEach(([char, code]) => {
            codeToChar[code] = char;
        });

        const emojiColorMap = {
            '🟥': 'red',
            '🟧': 'orange',
            '🟨': 'yellow',
            '🟩': 'green',
            '🟦': 'blue',
            '🟪': 'purple',
            '⬜': 'white',
            '⬛': 'black',
            '⬛️': 'black',  // Variation with variation selector
            '\u2B1B': 'black',  // Unicode escape sequence
            '\u2B1B\uFE0F': 'black',  // Unicode with variation selector
            '■': 'block-filled'
        };

        createApp({
            setup() {
                // State
                const boardContent = ref(Array(132).fill(' '));
                const currentMode = ref('');
                const debugStatus = ref('Loading...');
                const cronSchedule = ref('Loading...');
                const messageInput = ref('');
                const messageStatus = ref({ text: '', color: '#666' });
                const calendarAuthStatus = ref('Checking...');
                const calendarEvents = ref('No events found');
                const calendarEventsTimestamp = ref('');
                const patternTest = ref({
                    mode: 'None',
                    result: 'Not tested',
                    time: 'N/A',
                    color: '#666'
                });
                const boardContentIntervalId = ref(null);
                const isMessageModalOpen = ref(false);
                const messageTextarea = ref(null);
                const isImageModalOpen = ref(false);

                // Create reverse character map (code to char)
                const reverseCharMap = {};
                Object.entries(charMap).forEach(([char, code]) => {
                    reverseCharMap[code] = char;
                });

                // Animation configuration
                const ANIMATION_DELAY = 16; // ~60fps for smooth rendering
                const CHARACTER_UPDATE_INTERVAL = 60; // ms between character changes
                const animatingCells = ref(new Set());
                const targetContent = ref(Array(132).fill(' '));
                const animationFrameId = ref(null);
                const pendingAnimations = ref(new Map()); // Track cells that need animation
                const lastCharacterUpdate = ref(0); // Track last character update time

                // Get the next character in the sequence
                const getNextChar = (currentChar, targetChar) => {
                    if (currentChar === targetChar) return currentChar;
                    
                    // Get the current and target character codes
                    let currentCode = charMap[currentChar];
                    let targetCode = charMap[targetChar];
                    
                    if (currentCode === undefined && typeof currentChar === 'string' && currentChar.length === 1) {
                        currentCode = charMap[currentChar.toUpperCase()];
                    }
                    if (targetCode === undefined && typeof targetChar === 'string' && targetChar.length === 1) {
                        targetCode = charMap[targetChar.toUpperCase()];
                    }
                    
                    if (currentCode === undefined || targetCode === undefined) {
                        return targetChar;
                    }
                    
                    const maxCode = 71;
                    const nextCode = (currentCode + 1) > maxCode ? 0 : currentCode + 1;
                    
                    if (nextCode === currentCode) return targetChar;
                    
                    return reverseCharMap[nextCode] || targetChar;
                };

                // Batch animation system
                const animateAllCells = (timestamp) => {
                    if (!pendingAnimations.value.size) {
                        animationFrameId.value = null;
                        return;
                    }

                    // Check if enough time has passed for character updates
                    const shouldUpdateCharacters = timestamp - lastCharacterUpdate.value >= CHARACTER_UPDATE_INTERVAL;

                    if (shouldUpdateCharacters) {
                        // Create a new board state only once per character update
                        const newBoardState = [...boardContent.value];
                        let hasUpdates = false;

                        // Update all pending cells in one pass
                        pendingAnimations.value.forEach((targetChar, index) => {
                            const currentChar = newBoardState[index];
                            if (currentChar !== targetChar) {
                                const nextChar = getNextChar(currentChar, targetChar);
                                newBoardState[index] = nextChar;
                                hasUpdates = true;
                                
                                if (nextChar === targetChar) {
                                    pendingAnimations.value.delete(index);
                                    animatingCells.value.delete(index);
                                }
                            } else {
                                pendingAnimations.value.delete(index);
                                animatingCells.value.delete(index);
                            }
                        });

                        // Only update the reactive board state if there were changes
                        if (hasUpdates) {
                            boardContent.value = newBoardState;
                            lastCharacterUpdate.value = timestamp;
                        }
                    }

                    // Request next frame if there are still pending animations
                    if (pendingAnimations.value.size > 0) {
                        animationFrameId.value = requestAnimationFrame(animateAllCells);
                    }
                };

                // Update board content with batched animation
                const updateBoardContent = async (newContent) => {
                    // Cancel any existing animation
                    if (animationFrameId.value) {
                        cancelAnimationFrame(animationFrameId.value);
                    }

                    // Reset animation state
                    pendingAnimations.value.clear();
                    animatingCells.value.clear();
                    lastCharacterUpdate.value = 0;

                    // Initialize animation state for changed cells
                    for (let i = 0; i < newContent.length; i++) {
                        if (boardContent.value[i] !== newContent[i]) {
                            pendingAnimations.value.set(i, newContent[i]);
                            animatingCells.value.add(i);
                        }
                    }

                    // Start the animation loop if there are changes
                    if (pendingAnimations.value.size > 0) {
                        animationFrameId.value = requestAnimationFrame(animateAllCells);
                    }

                    // Return a promise that resolves when all animations are complete
                    return new Promise(resolve => {
                        const checkComplete = () => {
                            if (pendingAnimations.value.size === 0) {
                                resolve();
                            } else {
                                setTimeout(checkComplete, CHARACTER_UPDATE_INTERVAL);
                            }
                        };
                        checkComplete();
                    });
                };

                // Constants
                const modes = [
                    { name: 'TODAY', title: 'Today', subtitle: 'Hourly weather' },
                    { name: 'WEATHER', title: 'Weather', subtitle: '5-Day Forecast' },
                    { name: 'CALENDAR', title: 'Calendar', subtitle: 'Upcoming' },
                    { name: 'CLOCK', title: 'Clock', subtitle: 'PST' }
                ];

                const controlModes = ['MANUAL', 'CLOCK', 'WEATHER', 'CALENDAR', 'TODAY'];
                const testModes = ['CLOCK', 'WEATHER', 'CALENDAR', 'TODAY'];

                const contentTests = [
                    {
                        id: 'checkerboard',
                        name: 'Checkerboard',
                        content: Array(132).fill(' ').map((_, i) => 
                            (Math.floor(i / 22) + (i % 22)) % 2 === 0 ? '⬜' : '⬛️'
                        )
                    },
                    {
                        id: 'color-blocks',
                        name: 'Color Blocks',
                        content: Array(132).fill(' ').map((_, i) => {
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            const blockSize = 22;
                            const colorIndex = Math.floor(i / blockSize) % colors.length;
                            return colors[colorIndex];
                        })
                    },
                    {
                        id: 'diagonal-weave',
                        name: 'Diagonal Weave',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            return ((row + col) % 3 === 0) ? '⬛️' : '⬜'
                        })
                    },
                    {
                        id: 'interlocking-t',
                        name: 'Interlocking T',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            return (row % 3 === 1 || col % 3 === 1) ? '⬛️' : '⬜'
                        })
                    },
                    {
                        id: 'broken-stripes',
                        name: 'Broken Stripes',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            return ((col + Math.floor(row/2)) % 4 < 2) ? '⬛️' : '⬜'
                        })
                    },
                    {
                        id: 'maze-pattern',
                        name: 'Maze Pattern',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            return ((row % 4 < 2) !== (col % 4 < 2)) ? '⬛️' : '⬜'
                        })
                    },
                    {
                        id: 'color-gradient-weave',
                        name: 'Color Gradient Weave',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            const colorIndex = (row + Math.floor(col/4)) % colors.length;
                            return ((row + col) % 2 === 0) ? colors[colorIndex] : '⬜'
                        })
                    },
                    {
                        id: 'rainbow-diamonds',
                        name: 'Rainbow Diamonds',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            const dist = Math.abs(row - 2.5) + Math.abs(col - 10.5);
                            return colors[Math.floor(dist) % colors.length]
                        })
                    },
                    {
                        id: 'color-steps',
                        name: 'Color Steps',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            return colors[Math.floor((row + col) / 3) % colors.length]
                        })
                    },
                    {
                        id: 'rainbow-maze',
                        name: 'Rainbow Maze',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            const mazeVal = (row % 3) * 2 + (col % 3);
                            return ((row % 3 === 1) || (col % 3 === 1)) ? colors[mazeVal % colors.length] : '⬜'
                        })
                    },
                    {
                        id: 'color-waves',
                        name: 'Color Waves',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟦', '🟩', '🟨'];
                            const wave = Math.sin(col * 0.3 + row * 0.5);
                            const colorIndex = Math.floor((wave + 1) * colors.length / 2);
                            return colors[colorIndex]
                        })
                    },
                    {
                        id: 'spectrum-blocks',
                        name: 'Spectrum Blocks',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟧', '🟨', '🟩', '🟦', '🟪'];
                            const blockSize = 3;
                            const blockRow = Math.floor(row / blockSize);
                            const blockCol = Math.floor(col / blockSize);
                            return colors[(blockRow + blockCol) % colors.length]
                        })
                    },
                    {
                        id: 'herringbone',
                        name: 'Herringbone',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const pattern = ((row * 2 + col) % 4 < 2);
                            return pattern ? '🟦' : '⬜'
                        })
                    },
                    {
                        id: 'ikat-waves',
                        name: 'Ikat Waves',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟥', '🟦', '⬜'];
                            const colorIndex = Math.floor((Math.sin(col * 0.4 + row * 0.8) + 1) * 1.5);
                            return colors[colorIndex];
                        })
                    },
                    {
                        id: 'tartan',
                        name: 'Tartan',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟦', '🟩', '⬜', '🟥'];
                            const verticalStripe = Math.floor(col / 2) % colors.length;
                            const horizontalStripe = Math.floor(row / 2) % colors.length;
                            return (col % 4 === 0 || row % 4 === 0) ? colors[horizontalStripe] : colors[verticalStripe]
                        })
                    },
                    {
                        id: 'kente',
                        name: 'Kente Inspired',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const colors = ['🟨', '🟩', '🟥', '⬛️'];
                            const pattern = (col % 4) + (row % 2) * 2;
                            return colors[pattern % colors.length]
                        })
                    },
                    {
                        id: 'twill',
                        name: 'Twill Pattern',
                        content: Array(132).fill(' ').map((_, i) => {
                            const row = Math.floor(i / 22);
                            const col = i % 22;
                            const shift = row % 4;
                            const pattern = ((col + shift) % 4 < 2);
                            return pattern ? '🟦' : '⬜'
                        })
                    }
                ];

                // Helper function to find pattern by ID
                const findPatternById = (id) => contentTests.find(test => test.id === id);

                // Methods
                const fetchBoardContent = async () => {
                    try {
                        const response = await fetch('/api/board/content');
                        const data = await response.json();
                        
                        if (!Array.isArray(data) || !data.every(row => Array.isArray(row))) {
                            console.error('Unexpected data format:', data);
                            return;
                        }

                        const content = [];
                        data.forEach(row => {
                            row.forEach(charCode => {
                                // Use codeToChar map to convert API codes to characters
                                content.push(codeToChar[charCode] || ' ');
                            });
                        });
                        await updateBoardContent(content);
                    } catch (error) {
                        console.error('Error fetching board content:', error);
                    }
                };

                const updateStatus = async () => {
                    try {
                        const response = await fetch('/api/status');
                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.error || 'Failed to fetch status');
                        }
                        const data = await response.json();
                        
                        currentMode.value = data.currentMode;
                        debugStatus.value = data.debugMode ? '🟡 DEBUG MODE' : '🟢 LIVE';
                        document.body.classList.toggle('debug-mode', data.debugMode);
                        cronSchedule.value = data.cronSchedule?.description || '';

                        // Handle board content interval based on debug mode
                        if (data.debugMode) {
                            if (boardContentIntervalId.value) {
                                clearInterval(boardContentIntervalId.value);
                                boardContentIntervalId.value = null;
                            }
                        } else if (!boardContentIntervalId.value) {
                            boardContentIntervalId.value = setInterval(fetchBoardContent, 15000);
                        }
                    } catch (error) {
                        console.error('Error fetching status:', error);
                        currentMode.value = 'Error';
                        debugStatus.value = '❌ ERROR';
                        cronSchedule.value = 'Failed to fetch status';
                    }
                };

                const setMode = async (mode) => {
                    // Update UI immediately
                    currentMode.value = mode;
                    
                    try {
                        await fetch('/api/mode', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ mode })
                        });
                        // Still call updateStatus to sync other state
                        updateStatus();
                    } catch (error) {
                        console.error('Error setting mode:', error);
                        // Optionally revert the mode if the API call fails
                        // updateStatus() will handle this automatically
                    }
                };

                const toggleDebug = async () => {
                    try {
                        await fetch('/api/debug/toggle', { method: 'POST' });
                        updateStatus();
                    } catch (error) {
                        console.error('Error toggling debug mode:', error);
                    }
                };

                const openMessageModal = () => {
                    isMessageModalOpen.value = true;
                    document.body.classList.add('modal-open');
                    nextTick(() => {
                        if (messageTextarea.value) {
                            messageTextarea.value.focus();
                        }
                    });
                };

                const closeMessageModal = () => {
                    isMessageModalOpen.value = false;
                    document.body.classList.remove('modal-open');
                    messageInput.value = '';
                    messageStatus.value = { text: '', color: '#666' };
                };

                const sendMessage = async () => {
                    if (!messageInput.value.trim()) {
                        messageStatus.value = { text: 'Please enter a message', color: '#dc3545' };
                        return;
                    }

                    messageStatus.value = { text: 'Sending message...', color: '#666' };

                    try {
                        const response = await fetch('/api/board/message', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text: messageInput.value.trim() })
                        });

                        const data = await response.json();

                        if (response.ok) {
                            messageStatus.value = { text: 'Message sent successfully!', color: '#28a745' };
                            messageInput.value = '';
                            // Set mode to MANUAL after sending message
                            await setMode('MANUAL');
                            fetchBoardContent();
                            setTimeout(() => {
                                closeMessageModal();
                            }, 1500);
                        } else {
                            throw new Error(data.error || 'Failed to send message');
                        }
                    } catch (error) {
                        console.error('Error sending message:', error);
                        messageStatus.value = { text: `Error: ${error.message}`, color: '#dc3545' };
                    }
                };

                const testPattern = async (mode) => {
                    try {
                        const response = await fetch('/api/pattern/test', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ mode })
                        });
                        
                        const data = await response.json();
                        
                        patternTest.value = {
                            mode,
                            result: data.matches ? '✅ Match' : '❌ No Match',
                            time: new Date().toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }),
                            color: data.matches ? '#28a745' : '#dc3545'
                        };
                    } catch (error) {
                        console.error('Error testing pattern:', error);
                        patternTest.value = {
                            mode,
                            result: '❌ Error',
                            time: new Date().toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }),
                            color: '#dc3545'
                        };
                    }
                };

                const initiateCalendarAuth = () => {
                    window.location.href = '/auth/google';
                };

                const fetchCalendarEvents = async () => {
                    try {
                        calendarEvents.value = 'Loading...';
                        const response = await fetch('/calendar/events');
                        const data = await response.json();
                        
                        if (response.status === 401 && data.authUrl) {
                            calendarAuthStatus.value = 'Not Authenticated';
                            calendarEvents.value = 'Authentication required';
                        } else if (response.ok) {
                            calendarAuthStatus.value = 'Authenticated';
                            calendarEvents.value = Array.isArray(data) && data.length === 0 
                                ? 'No upcoming events found' 
                                : JSON.stringify(data, null, 2);
                        } else {
                            throw new Error(data.error || 'Failed to fetch events');
                        }
                        calendarEventsTimestamp.value = `Last updated: ${new Date().toLocaleString('en-US', { timeZone: 'America/Los_Angeles' })}`;
                    } catch (error) {
                        console.error('Error fetching calendar events:', error);
                        calendarEventsTimestamp.value = `Error occurred: ${new Date().toLocaleString('en-US', { timeZone: 'America/Los_Angeles' })}`;
                    }
                };

                const isColorEmoji = (char) => {
                    return char in emojiColorMap;
                };

                const getColorClass = (char) => {
                    return emojiColorMap[char];
                };

                const openImageModal = () => {
                    isImageModalOpen.value = true;
                    document.body.classList.add('modal-open');
                };

                const closeImageModal = () => {
                    isImageModalOpen.value = false;
                    document.body.classList.remove('modal-open');
                };

                const applyTestPattern = async (test) => {
                    // Close the modal
                    closeImageModal();

                    try {
                        // Convert the content array to a string by joining with spaces
                        const text = test.content.join('');

                        // Send the pattern to the API
                        const response = await fetch('/api/board/message', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ text })
                        });

                        if (!response.ok) {
                            const data = await response.json();
                            throw new Error(data.error || 'Failed to send pattern');
                        }

                        // Set mode to MANUAL after sending pattern
                        await setMode('MANUAL');
                        // Fetch the updated board content
                        fetchBoardContent();
                    } catch (error) {
                        console.error('Error applying test pattern:', error);
                    }
                };

                // Lifecycle hooks
                onMounted(() => {
                    fetchBoardContent();
                    updateStatus();
                    fetchCalendarEvents();

                    // Check URL parameters for auth status
                    const urlParams = new URLSearchParams(window.location.search);
                    const authStatus = urlParams.get('auth');
                    if (authStatus === 'success') {
                        calendarAuthStatus.value = 'Authentication Successful';
                    } else if (authStatus === 'error') {
                        calendarAuthStatus.value = 'Authentication Failed';
                    }

                    // Set up intervals - board content interval will be managed by updateStatus
                    setInterval(updateStatus, 15000);
                });

                return {
                    // State
                    boardContent,
                    currentMode,
                    debugStatus,
                    cronSchedule,
                    messageInput,
                    messageStatus,
                    calendarAuthStatus,
                    calendarEvents,
                    calendarEventsTimestamp,
                    patternTest,
                    boardContentIntervalId,
                    isMessageModalOpen,
                    messageTextarea,
                    isImageModalOpen,
                    // Animation
                    animatingCells,
                    ANIMATION_DELAY,
                    CHARACTER_UPDATE_INTERVAL,
                    // Constants
                    modes,
                    controlModes,
                    testModes,
                    contentTests,
                    // Methods
                    setMode,
                    toggleDebug,
                    openMessageModal,
                    closeMessageModal,
                    sendMessage,
                    testPattern,
                    initiateCalendarAuth,
                    fetchCalendarEvents,
                    isColorEmoji,
                    getColorClass,
                    openImageModal,
                    closeImageModal,
                    applyTestPattern,
                    findPatternById
                };
            }
        }).mount('#app');
    </script>
</body>
</html> 